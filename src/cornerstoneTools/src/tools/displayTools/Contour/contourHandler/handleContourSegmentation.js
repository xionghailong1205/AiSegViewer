import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';
import { cache, utilities } from '@cornerstonejs/core';
import { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';
import { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';
import { validateGeometry } from './utils';
import { SegmentationRepresentations } from '../../../../enums';
import { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';
function handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {
    if (annotationUIDsMap.size) {
        viewport.render();
    }
    else {
        addContourSetsToElement(viewport, geometryIds, contourRepresentation);
    }
}
function addContourSetsToElement(viewport, geometryIds, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentSpecificMap = new Map();
    geometryIds.forEach((geometryId) => {
        const geometry = cache.getGeometry(geometryId);
        if (!geometry) {
            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const segmentIndex = geometry.data.segmentIndex;
        validateGeometry(geometry);
        const segmentSpecificConfig = segmentationStyle.getStyle({
            viewportId: viewport.id,
            segmentationId,
            type: SegmentationRepresentations.Contour,
            segmentIndex,
        });
        const contourSet = geometry.data;
        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;
        contourSet.contours.forEach((contour) => {
            const { points, color, id } = contour;
            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);
            const contourSegmentationAnnotation = {
                annotationUID: utilities.uuidv4(),
                data: {
                    contour: {
                        closed: true,
                        polyline: points,
                    },
                    segmentation: {
                        segmentationId,
                        segmentIndex,
                        color,
                        id,
                    },
                    handles: {},
                },
                handles: {},
                highlighted: false,
                autoGenerated: false,
                invalidated: false,
                isLocked: true,
                isVisible: true,
                metadata: {
                    referencedImageId,
                    toolName: 'PlanarFreehandContourSegmentationTool',
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,
                },
            };
            const annotationGroupSelector = viewport.element;
            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);
            addContourSegmentationAnnotation(contourSegmentationAnnotation);
        });
        if (segmentSpecificConfig) {
            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);
        }
    });
    viewport.resetCamera();
    viewport.render();
}
export { handleContourSegmentation, addContourSetsToElement };
