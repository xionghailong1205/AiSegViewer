import type { Types } from '@cornerstonejs/core';
import { ChangeTypes } from '../../enums';
import type { EventTypes, ToolHandle, PublicToolProps, ToolProps, SVGDrawingHelper } from '../../types';
import type { LivewireContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';
import { LivewireScissors } from '../../utilities/livewire/LivewireScissors';
import { LivewirePath } from '../../utilities/livewire/LiveWirePath';
import ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';
import type { AnnotationStyle } from '../../types/AnnotationStyle';
declare class LivewireContourTool extends ContourSegmentationBaseTool {
    static toolName: string;
    protected scissors: LivewireScissors;
    protected scissorsNext: LivewireScissors;
    _throttledCalculateCachedStats: Function;
    editData: {
        annotation: LivewireContourAnnotation;
        viewportIdsToRender: Array<string>;
        handleIndex?: number;
        movingTextBox?: boolean;
        newAnnotation?: boolean;
        hasMoved?: boolean;
        lastCanvasPoint?: Types.Point2;
        confirmedPath?: LivewirePath;
        currentPath?: LivewirePath;
        confirmedPathNext?: LivewirePath;
        closed?: boolean;
        worldToSlice?: (point: Types.Point3) => Types.Point2;
        sliceToWorld?: (point: Types.Point2) => Types.Point3;
        originalPath?: Types.Point3[];
        contourHoleProcessingEnabled?: boolean;
    } | null;
    isDrawing: boolean;
    isHandleOutsideImage: boolean;
    constructor(toolProps?: PublicToolProps, defaultToolProps?: ToolProps);
    protected setupBaseEditData(worldPos: any, element: any, annotation: any, nextPos?: any, contourHoleProcessingEnabled?: any): void;
    addNewAnnotation(evt: EventTypes.InteractionEventType): LivewireContourAnnotation;
    isPointNearTool: (element: HTMLDivElement, annotation: LivewireContourAnnotation, canvasCoords: Types.Point2, proximity: number) => boolean;
    toolSelectedCallback: (evt: EventTypes.InteractionEventType, annotation: LivewireContourAnnotation) => void;
    handleSelectedCallback: (evt: EventTypes.InteractionEventType, annotation: LivewireContourAnnotation, handle: ToolHandle) => void;
    _endCallback: (evt: EventTypes.InteractionEventType, clearAnnotation?: boolean) => void;
    protected clearEditData(): void;
    triggerChangeEvent: (annotation: LivewireContourAnnotation, enabledElement: Types.IEnabledElement, changeType?: ChangeTypes, contourHoleProcessingEnabled?: boolean) => void;
    private _mouseDownCallback;
    private _mouseMoveCallback;
    editHandle(worldPos: Types.Point3, element: any, annotation: LivewireContourAnnotation, handleIndex: number): void;
    private _dragCallback;
    cancel: (element: HTMLDivElement) => string;
    private _activateModify;
    private _deactivateModify;
    private _activateDraw;
    private _deactivateDraw;
    renderAnnotation(enabledElement: Types.IEnabledElement, svgDrawingHelper: SVGDrawingHelper): boolean;
    protected isContourSegmentationTool(): boolean;
    protected createAnnotation(evt: EventTypes.InteractionEventType): import("../../types").ContourAnnotation;
    undo(element: any, config: any, evt: any): void;
    protected renderAnnotationInstance(renderContext: {
        enabledElement: Types.IEnabledElement;
        targetId: string;
        annotation: LivewireContourAnnotation;
        annotationStyle: AnnotationStyle;
        svgDrawingHelper: SVGDrawingHelper;
    }): boolean;
    private _calculateCachedStats;
    private _renderStats;
    triggerAnnotationModified: (annotation: LivewireContourAnnotation, enabledElement: Types.IEnabledElement, changeType?: ChangeTypes) => void;
    protected updateAnnotation(livewirePath: LivewirePath): void;
}
export default LivewireContourTool;
